#!/bin/bash

#------------------------------------------------------------------------------
# Setup a Debian-based VPS for remote pair hacking.
#
# It is tested on Ubuntu 12.04 and 14.04.
#------------------------------------------------------------------------------

# TODO:
# - Allow -u user:githubuser
# - Use `git rev-parse` to parse options
# - Support 0-n user list. Default to ($USER:$USER)
# - Support multiple -p projects

set -e

GETOPT_SPEC="\
${0##*/} <ip-address> [<pairup-userid>...] <options>

Set up a brand new remote VM for PairUp.

Options:
--
h           Help
q,quiet     Show minimal output
v,verbose   Show verbose output
 
a,admin=        Admin UserID (default to \$USER)
p,project=      Project name to include
 
A,aws           Remote VM is on AWS
D,digitalocean  Remote VM is on DigitalOcean
H,hpcloud       Remote VM is on HP Cloud
L,liquidweb     Remote VM is on Liquid Web
R,rackspace     Remote VM is on Rackspace
 
B,build-only    Just build the PairUp directory
"

source "${BASH_SOURCE%/*}/../lib/pairup-util.bash"

# main() is called at bottom of this file:
main() {
  # "Global" variables we use:
  local root_user= sudo=
  local vm_address= admin_user= pair_users=
  local quiet_output= verbose_output=

  # Make sure our runtime environment is ok:
  assert-env

  # XXX For now we run the test suite every time:
  tests_ok ||
    die "The pairup test suite is failing. You should look into that."

  # Parse command line options:
  get-opts "$@"

  # Stage custom scripts in ./.PairUp/
  build-config

  # Exit if just testing ./.PairUp/
  if [ -n "$PAIRUP_BUILD_ONLY" ]; then
    echo 'Build complete'
    exit
  fi

  # Make script noisy now:
  set -x

  # Set up ssh key for root. May prompt for root password, depending on the
  # server setup. This is the only time you need to enter the password. All
  # pubkey afterwards:
  if [ "$root_user" == root ]; then
    cat "$PairUp/keys/${admin_user%:*}/authorized_keys" |
      ssh "$root_user@$vm_address" \
      "cat > ak; mkdir -p .ssh; chmod 700 .ssh; mv ak .ssh/authorized_keys"
  fi

  # Copy PairUp dir over to root:
  rsync -avz $PairUp/ "$root_user@$vm_address:$PairUp"

  # Run the interactive root script:
  ssh -t "$root_user@$vm_address" $sudo bash "$PairUp/root-setup"

  # Run the interactive admin_user script:
  ssh -t "${admin_user%:*}@$vm_address" bash "$PairUp/admin-setup" \
    || true   # Show reconnect msg if the tmux fails

  # \oXo/
  # Now you should be inside a perfectly working tmux session for pairing!
  # \oXo/

  # Tell admin user how to reconnect when they leave tmux session:
  cat $PairUp/reconnect
}

# cd to the pairup repo directory:
assert-env() {
  # Check for needed system commands:
  for dep in git rsync ssh; do
    if ! type $dep &>/dev/null; then
      die "Missing dependency '$dep'"
    fi
  done

  # cd to the pairup repo:
  pairup_bin="$0"
  [[ "$pairup_bin" =~ ^bin/[A-Za-z0-9_-]+$ ]] &&
    pairup_bin="./$pairup_bin"
  [[ "$pairup_bin" =~ .+/bin/[A-Za-z0-9_-]+$ ]] ||
    die "Invalid invocation path: '$pairup_bin'"
  cd ${pairup_bin%/bin/*} ||
    die "Can't cd to pairup repo"

  # Get the repo name to use:
  pairup_repo="$(
    git remote -v |
    grep -E '^origin' |
    head -n1 |
    cut -f2 |
    cut -d ' ' -f1
  )"
  [ -n "$pairup_repo" ] ||
    die "Can't find remote"
  [[ "$pairup_repo" =~ github\.com ]] ||
    die "'$pairup_repo' is bad repo name"

}

# Parse command line args:
get-opts() {
  [ $# -eq 0 ] && set -- --help

  eval "$(
    echo "$GETOPT_SPEC" |
    git rev-parse --parseopt -- "$@" ||
      echo "exit $?"
  )"

  project_list=()
  root_user=root
  quiet_output=false
  verbose_output=false
  admin_user="$USER"

  while [ $# -gt 0 ]; do
    local option="$1"; shift
    case "$option" in
      -a) admin_user="$1"; shift ;;
      -p) project_list+=("$1") ;;
      -A) die "AWS not tested yet" ;;
      -D) ;;
      -H)
        sudo=sudo
        root_user=ubuntu
        ;;
      -L) ;;
      -R) ;;

      -B) PAIRUP_BUILD_ONLY=1 ;;

      -q) quiet_output=true ;;
      -v) verbose_output=true ;;

      --) break ;;

      *) error "unexpected option '$option'" ;;
    esac
  done

  vm_address="${1:?Server Address Required}"; shift
  [[ "$vm_address" =~ \. ]] ||
    die "Invalid Server Address: '$vm_address'"
  pair_users=("$@")

  # Detect HPCS:
  if [[ "$vm_address" =~ ^15\.125\. ]]; then
    sudo=sudo
    root_user=ubuntu
  fi
}

# Copy everything the server will need into $PairUp/ and make sure both users
# have a public key:
build-config() {
  [ ! -d "$PairUp" ] || rm -fr $PairUp
  mkdir -p $PairUp

  cat <<... > $PairUp/pairup-env
export PAIRUP_ROOT=~/.PairUp
export PAIRUP=true
export PAIRUP_ADMIN="$admin_user"
export PAIRUP_ROOT_USER="$root_user"
export PAIRUP_PAIRS=(${pair_users[@]})
export PAIRUP_VMADDR="$vm_address"
export PAIRUP_STARTED="$(date)"
export PAIRUP_REPO="$pairup_repo"
...

cat <<... > $PairUp/reconnect

Connect to PairUp with:

    ssh -t "${admin_user%:*}@$vm_address" pairup

...

cat <<... > $PairUp/motd

Welcome to your new PairUp server tmux session!

Tell $pair_users to run this command:

    ssh -t $pair_users@$vm_address pairup

-------------------------------------------------------------------------------
...

  cp -r bin $PairUp/
  cp -r lib $PairUp/
  mkdir $PairUp/user
  mkdir $PairUp/keys
  for f in conf/*; do
    if [[ ! "$f" =~ /\. ]] && [ -f "$f" ]; then
      cp "$f" $PairUp/
    fi
  done

  # Take the default conf files and append the appropriate user conf files to
  # each one:
  for user in "$admin_user" "${pair_users[@]}"; do
    local unix_user="${user%:*}"
    mkdir "$PairUp/keys/$unix_user"
    if [ -f "conf/user/$unix_user" ]; then
      cp "conf/user/$unix_user" "$PairUp/user/$unix_user"
    fi
    assert-public-key
  done

  cp -p share/bin/root-setup $PairUp/
  cp -p share/bin/admin-setup $PairUp/
}

# Use the rsa public key under ./user/$unix_user/authorized_keys or attempt to
# get one from GitHub, or error out:
assert-public-key() {
  local unix_user= github_user=
  if [[ "$user" =~ : ]]; then
    unix_user="${user%:*}"
    github_user="${user#*:}"
  else
    unix_user="$user"
  fi
  if [ -z "$github_user" ]; then
    github_user="$(
      grep -Esh "^$unix_user:" $PairUp/github-users* |
      head -n1 | cut -d: -f2
    )"
    github_user="${github_user:-$unix_user}"
  fi
  local keys=$(
    curl --silent "https://api.github.com/users/$github_user/keys"
  )
  local rsa_keys=$(
    echo "$keys" |
    grep -E '^    "key": "ssh-rsa' |
    cut -d'"' -f4
  )
  local dsa_keys=$(
    echo "$keys" |
    grep -E '^    "key": "ssh-dss' |
    cut -d'"' -f4
  )
  if [ -n "$rsa_keys" ]; then
    echo "$rsa_keys" > "$PairUp/keys/$unix_user/authorized_keys"
  fi
  if [ -n "$dsa_keys" ]; then
    echo "$dsa_keys" > "$PairUp/keys/$unix_user/authorized_keys2"
  fi
  [ -s "$PairUp/keys/$unix_user/authorized_keys" ] ||
  [ -s "$PairUp/keys/$unix_user/authorized_keys2" ] ||
    die "Can't find a public key for user '$unix_user:$github_user'"
  :
}

# Start the PairUp server setup:
[ "$0" != "$BASH_SOURCE" ] || main "$@"

# vim: set lisp:
